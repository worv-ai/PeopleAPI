# Copyright (c) 2022, NVIDIA CORPORATION.  All rights reserved.
#
# NVIDIA CORPORATION and its licensors retain all intellectual property
# and proprietary rights in and to this software, related documentation
# and any modifications thereto.  Any use, reproduction, disclosure or
# distribution of this software and related documentation without an express
# license agreement from NVIDIA CORPORATION is strictly prohibited.

from omni.metropolis.utils.type_util import TypeUtil
from omni.anim.people_api.scripts.utils import Utils
from pxr import Gf

from .base_command import Command, MetadataTag


class TalkWith(Command):
    """
    Command class to talk with certain character in the stage.
    """

    def __init__(self, *args, **kwargs):
        super().__init__(*args, **kwargs)
        self.command_name = "Talk"
        self.current_action = "rotate_to_target"
        self.talk_time = self.command[2]
        self.talk_time_counter = 0
        self.target_character_name = self.command[1]
        self.max_attempts = 1000
        self.path_confirmed = False
        self.set_up_command_description()

    # calculate the best position of conducting talk animation.
    def find_point(self, A, B):
        x1, y1, z1 = A
        x2, y2, z2 = B

        # calculate an appropriate point
        Px = x1 + (1 / 5) * (x2 - x1)
        Py = y1 + (1 / 5) * (y2 - y1)
        Pz = z1 + (1 / 5) * (z2 - z1)

        return Gf.Vec3d(Px, Py, Pz)

    def get_valid_talk_position(self, target_character_name):
        """
        generate a valid navigation path from current poisiton to talking position
        """

        start_point = Utils.get_character_pos(self.character)
        start_point = Gf.Vec3d(start_point[0], start_point[1], start_point[2])
        # Calculate end point
        end_point = Utils.get_character_position_by_name(str(target_character_name))
        end_point = Gf.Vec3d(end_point[0], end_point[1], end_point[2])
        # carb.log_warn("This is the rotation end point of the character" + str(end_point))
        world_offset = start_point - end_point

        # Calculate end rotation (facing the target character)
        end_dir = Gf.Vec3d(-world_offset[0], -world_offset[1], 0).GetNormalized()
        end_quat = Gf.Rotation(Gf.Vec3d(0, -1.0, 0), end_dir).GetQuat()
        end_rot = TypeUtil.gf_quatd_to_carb_float4(end_quat)
        # communicating_point
        talking_position = Utils.get_closest_navmesh_point(self.find_point(start_point, end_point))  # noqa: F841

        self.navigation_manager.generate_path(
            [
                start_point,
            ],
            end_rot,
        )
        return

    def setup(self):
        super().setup()
        self.character.set_variable("Action", "Walk")
        if len(self.command) >= 3:
            self.talk_time = float(self.command[2])

        self.get_valid_talk_position(self.target_character_name)

    def set_up_command_description(self):
        # set up command description for talk command:
        # since talk command does not generated by agent.
        self.command_description = "{character_name} talks with {target_character_name}.".format(
            character_name=self.character_name, target_character_name=self.target_character_name
        )

    def execute(self, dt):
        if self.finished:
            return True

        if not self.is_setup:
            self.setup()
        return self.update(dt)

    def update(self, dt):

        # update the character's rotation, let it face the target character
        self.time_elapsed += dt
        if self.current_action == "rotate_to_target" or self.current_action is None:

            if self.walk(dt):
                # if True:
                # carb.log_warn("Finish rotation : " + str(self.character_name))
                self.current_action = "talk"

            return

        # start talking with
        elif self.current_action == "talk":
            self.update_metadata_callback(
                agent_name=self.character_name, data_name=MetadataTag.AgentActionTag, data_value="Talking"
            )
            # self.character.set_variable("Action", "None")
            self.character.set_variable("Action", "Talk")
            # self.character.set_variable("lookaround", 1.0)
            self.talk_time_counter += dt
            if self.talk_time_counter > self.talk_time:
                self.character.set_variable("Action", "None")
                self.update_metadata_callback(
                    agent_name=self.character_name, data_name=MetadataTag.AgentActionTag, data_value="Idle"
                )
                # self.character.set_variable("lookaround", 0.0)
                return self.exit_command()

    # interrupt current talking and inject another command
    def force_quit_command(self):
        # self.character.set_variable("lookaround", 0.0)
        return super().force_quit_command()
